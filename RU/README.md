# BaseFunctionsJS_RU

## Вступление

В этом гайде вы сможете получить основные зания по JavaScript. Причиной написания гайда была сложность и запутаность которую я заметил в другий гайдах и руководствах. Безусловно я не эксперт в JavaScript, но при этом имею какой-то опыт и думаю, что могу помочь этими знаниями другим :)

## Полезные ссылки

Так как этот гайд достаточно субъективный я не уверен что захвачу все темы и не уверен что у нас не появяться вопросы после прочтения, по-этому в этом блоке прикреплю хорошие ссылки который можно использовать в таких случаях.

В первую очередь вы можете написать мне на почты и я попробую вам помочь:

boyarkin.gleb@gmail.com;

source.boar@gmail.com

Так же почты подублированы у меня в профиле.

Кроме меня вы можете воспользоваться: 

https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference

Эти источники гарантирую что являються проверенными, сам по ним учился, но как по мне многие вещи там расписаны слишком сложными словами.

## Коротко про JavaScript

JavaScript (JS) — достаточно молодой и известный динамический язык программирования. Основной отраслью применения являеться в первую очередь Web разработка, а так же разработка приложений.

## Синтаксис

Синтаксис JS в большинстве своём явяеться С-подобным, но со своими мелкими отличиями, с которыми мы будем сталкиваться по ходу. 

**Если проходиться по основным правилам синтаксиса то:**

* `;` – символ окончания строки

* `{}` – сиволы для открытия и закрытия блоков кода

* `camelCase` – стиль именования переменный и функций

* `PascalCase` – стиль именования классов

* `//` – символ для комментария отдной строки

* `/* */` – символы для комментирования блока кода

## Переменные

Как я думаю вам известно, или станет известо сейчас, по факту весь язык программирования держиться на переменных и операциях над ними.

В JS переменная — это указатель на область или ячейку памяти в которой хранится какое то зничени. Факт про память пока можно просто положить в голову, к нему мы прийдем потом.

Для объявления переменных используються ключевые слова `var`, `let` и `const`.

***Пример объявления***:

```js
var a1 = "Hello";
let a2 = 1;
const A3 = true;
```

При именовании переменных, как указано было выше, используеться стиль camelCase.

Что ж в него входит?

**camelCase:**

* первая буква – нижнего регистра

* каждая первая буква следуещего слова – верхнего регистра

Так же если конкретно про JS то в нем название переменной может начинать с символа `_` или буквы любого регистра, последующие символы уже могут быть такие же плюс цифры(0-9). Так же стоит уточнить что JS чувствителен к регистру, то есть в нем `a` и `A` это разные имена.

### Разница между `var`, `let` и `const`

* `var` – способ объявления переменной с контекстной областью видимости, не требует значения при объявлении, по умолчанию `undefined`, переменная может быть переобъявлена. Данный способ объявления считается устаревшим, и рекомендуется вместо него использовать `let`

* `let` – способ объявления переменной с блочной областью видимости, не требует значения при объявлении, по умолчанию `undefined`, переменная не может быть переобъявлена.

* `const` – способ объявления переменной с блочной областью видимости, но при этом доступ в дальнейшем к переменной после объявления только для чтения, из этого исходит что значение при объявлении является обязательным. Так же константые переменные принято именовать буквами верхнего регистра, но это не являеться обязательным.

* `Без ключевого слова` – способ объявления переменной с глоабльной областью видимости

#### А теперь простыми словами

**Область видимости** — участок программы на котором ваша переменная, функция, класс будут видны другим объектам программы.

**Глобальная область видимости** — областью видимости являеться вся программа

**Блочная область видимости** – область видимости в пределах блока программы

**Блок программы** – функция, класс, вся программа

**Контекстная область видимости** — область видимости в зависимости от контекста объявления: при объявлении в функии область видимости будет эта функция, при объявлении во всей программе область видимости будет вся программа итд.

***Примеры***

```js 
var a1 = 1;
let a2 = 2;
const A3 = 3;
a4 = 4;

function f(){
    var f1 = 1;
    let f2 = 2;
    const F3 = 3;
    f4 = 4;
}

f();

function g(){
    console.log(a1); // выведет
    console.log(a2); // выведет
    console.log(A3); // выведет
    console.log(a4); // выведет
    console.log(f1); // не выведет
    console.log(f2); // не выведет
    console.log(F3); // не выведет
    console.log(f4); // выведет
}

g();

function h(){
    var a1 = 0; // сработает
    let a2 = 0; // сработает "но"
    const A3 = 0; // сработает "но"
    a4 = 0; // сработает
    f4 = 0; // сработает
}

h();

var a1 = 0; // сработает
let a2 = 0; // не сработает
const A3 = 0; // не сработает
a4 = 0; // сработает
```

**А теперь разберем что происходит:**

1. Переменные `a1`, `a2`, `A3`, `a4` объявлены на уровне программы, а `f1`, `f2`, `F3`, `f4` на уровне функции.

2. Что будет с `var`: 
    
    1. Из-за контекстной типизации `a1` станет глобальной, а `f1` локальной переменными, из-за чего в функции `g` `а1` будет видна, а `f1` нет

    2. В функции `h` или в самой программе переменную `a1` можно будет объявить заново

3. Что будет с `let`:

    1.  Из-за блочной типизации `a2` будет видна всей программе, а `f2` только функции в которой объявлена, из-за чего в функции `g` `а2` будет видна, а `f2` нет

    2. В функции `h` переменную `a2` можно будет объявить заново, "но" теперь `a2` для всего блока программы будет новой и старая не будет доступна

    3. На уровне блока, на котором была задана `a2`, переобъявить её уже будет нельзя

4. Что будет с `const`:

    1.  Из-за блочной типизации `A3` будет видна всей программе, а `F3` только функции в которой объявлена, из-за чего в функции `g` `A3` будет видна, а `F3` нет

    2. В функции `h` переменную `A3` можно будет объявить заново, "но" теперь `A3` для всего блока программы будет новой и старая не будет доступна

    3. На уровне блока, на котором была задана `A3`, переобъявить её уже будет нельзя

    4. Изменить значение никакой из переменных этого типа будет невозможно

5. Что будет с `без ключевого слова`:

    1. Обе переменные станут глобальными из-за глобальной области видимости

    2. Переобъявление не отличаеться от переназначения так что технически её можно будет изменять как угодно в каком угодно блоке программы.

#### Почему `var` считается устаревшей?

Как мы увидели выше: переменные объявленые через `var` могут переобъявляться из-за чего могут возникать массы ошибок и несостыковок в коде. Что б решить эту проблему был создан `let` который в свою очередь такими проблемами не страдает.

### Типы данных

В JS есть 7 примитивных типо данных.

**Тип данных** — типы того, какого типа значение может хранить переменная.

**Примитивы (примитивные типы данных)** — типы данных которые не являються объектами и не имеют методов.

***Простыми словами:*** самые простые системные типы данных.

**Примитивы в JS:**

* `Boolean` – логический тип данных, хранит 2 вида значений: `true` или `false`

* `Number` – числовой тип данных, хранит числа в диапазоне приблизительно от _-2*10^307_ до _2*10^307_, в случаее передачи значения меньше будет записіваться `-Infinity`, а больше – `Infinity`

* `String` – строчный тип данных, хранит строку текста почти неограниченого размера

* `null` – ключевое слово, которое означает что нулевое или "пустое" значение

* `undefined` – ключевое слово, которое означает что переменная не хранит никакого значение, по умолчанию присваивается всем переменных при объявлении без значение, за исключением `const`

### Типизация

Типизация JS – это динамическая, слабая, неявная.

**А теперь попробуем понять:**

* Динамическая – значит что переменная не привязана к единому типу при объявлении, переменная может хранить разные типы по ходу использования программы

* Слабая – значит что при проделование действий с переменной одного типа действий другого типа не будет вызывать ошибку. *Известный пример*: `1 + "2" == "12"`, то есть что число попытались просумировать со строкой, но это не вызвало оишбку и сработало

* Неявная – значит что при объявлении не нужно "явно" указывать тип переменной. *Например как это в С++ с явной типизацией:* `string a = "a"`, когда в JS хватит `let a = "a"`, без указание типа

***Статья, где эта тема раскрыта глубже:*** https://tproger.ru/explain/tipizacija-jazykov-programmirovanija-razbiraemsja-v-osnovah/


#### Что же нам дают эти зания?

Из типизации JS мы можем извлечь те факты, что:

* Нам не нужно следить за типами на уровне программы

* Нам не нужно объявлять переменную указывая её тип 

* Мы можем для одной переменной присваивать значения разных типов

### Расмотрим конкретно разные типы

#### Boolean

Это логический тип данных, который используется в местах, где нужно в переменной хранить 2 варианта значения: ДА (`true`) или НЕТ (`false`)

***Объявления переменных этого типа могут выглядить так:***

```js
let t = true;
let f = false;
```

Используються они, в основном, в логических блоках, которые мы расмотрим позже

#### Number

Числовой тип данных. Может хранить разные числа: положительные, отрицательные, ноль, целые, не целые...

***Объявления переменных этого типа могут выглядить так:***

```js
let n = 2;
let p = 3.14;
let m = -4;
let o = 0;
```

Так же для преобразование переменных другого типа в `Number` можно использовать функции `ParseInt(string)`, `ParseFloat(string)` или просто созданием объекта `Number()`

#### String

Сточный тип данных, хранит в себе текст.

***Объявления переменных этого типа могут выглядить так:***

```js
let txt1 = "Hello";
let txt2 = 'World';
let txt3 = `!`;
```

Разницы между кавычками нету (за исключением ``, но про это не сейчас), главное что б они открывали и закрывали строку одновременно.

Так же для преобразование переменных другого типа в `String` можно использовать функции `String()` или `.toString()`

Так же для строк существует очень большое количество методов, перечень которых и инструкции к ним можно най по ссылке: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String