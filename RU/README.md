# BaseFunctionsJS_RU

## Вступление

В этом гайде вы сможете получить основные зания по JavaScript. Причиной написания гайда была сложность и запутаность которую я заметил в другий гайдах и руководствах. Безусловно я не эксперт в JavaScript, но при этом имею какой-то опыт и думаю, что могу помочь этими знаниями другим :)

## Полезные ссылки

Так как этот гайд достаточно субъективный я не уверен что захвачу все темы и не уверен что у нас не появяться вопросы после прочтения, по-этому в этом блоке прикреплю хорошие ссылки который можно использовать в таких случаях.

В первую очередь вы можете написать мне на почты и я попробую вам помочь:

boyarkin.gleb@gmail.com;

source.boar@gmail.com

Так же почты подублированы у меня в профиле.

Кроме меня вы можете воспользоваться: 

https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference

Эти источники гарантирую что являються проверенными, сам по ним учился, но как по мне многие вещи там расписаны слишком сложными словами.

## Коротко про JavaScript

JavaScript (JS) — достаточно молодой и известный динамический язык программирования. Основной отраслью применения являеться в первую очередь Web разработка, а так же разработка приложений.

## Синтаксис

Синтаксис JS в большинстве своём явяеться С-подобным, но со своими мелкими отличиями, с которыми мы будем сталкиваться по ходу. 

**Если проходиться по основным правилам синтаксиса то:**

* `;` – символ окончания строки

* `{}` – сиволы для открытия и закрытия блоков кода

* `camelCase` – стиль именования переменный и функций

* `PascalCase` – стиль именования классов

* `//` – символ для комментария отдной строки

* `/* */` – символы для комментирования блока кода

## Мелкая важная заметка

`consoe.log(x);` — функция для вывода какого либо `x` в консоль. Конкретнее про это будет дальше, но это нужно для понимания ближайшего участка кода

## Переменные

Как я думаю вам известно, или станет известо сейчас, по факту весь язык программирования держиться на переменных и операциях над ними.

В JS переменная — это указатель на область или ячейку памяти в которой хранится какое то зничени. Факт про память пока можно просто положить в голову, к нему мы прийдем потом.

Для объявления переменных используються ключевые слова `var`, `let` и `const`.

***Пример объявления***:

```js
var a1 = "Hello";
let a2 = 1;
const A3 = true;
```

При именовании переменных, как указано было выше, используеться стиль camelCase.

Что ж в него входит?

**camelCase:**

* первая буква – нижнего регистра

* каждая первая буква следуещего слова – верхнего регистра

Так же если конкретно про JS то в нем название переменной может начинать с символа `_` или буквы любого регистра, последующие символы уже могут быть такие же плюс цифры(0-9). Так же стоит уточнить что JS чувствителен к регистру, то есть в нем `a` и `A` это разные имена.

### Разница между `var`, `let` и `const`

* `var` – способ объявления переменной с контекстной областью видимости, не требует значения при объявлении, по умолчанию `undefined`, переменная может быть переобъявлена. Данный способ объявления считается устаревшим, и рекомендуется вместо него использовать `let`

* `let` – способ объявления переменной с блочной областью видимости, не требует значения при объявлении, по умолчанию `undefined`, переменная не может быть переобъявлена.

* `const` – способ объявления переменной с блочной областью видимости, но при этом доступ в дальнейшем к переменной после объявления только для чтения, из этого исходит что значение при объявлении является обязательным. Так же константые переменные принято именовать буквами верхнего регистра, но это не являеться обязательным.

* `Без ключевого слова` – способ объявления переменной с глоабльной областью видимости

#### А теперь простыми словами

**Область видимости** — участок программы на котором ваша переменная, функция, класс будут видны другим объектам программы.

**Глобальная область видимости** — областью видимости являеться вся программа

**Блочная область видимости** – область видимости в пределах блока программы

**Блок программы** – функция, класс, вся программа

**Контекстная область видимости** — область видимости в зависимости от контекста объявления: при объявлении в функии область видимости будет эта функция, при объявлении во всей программе область видимости будет вся программа итд.

***Примеры***

```js 
var a1 = 1;
let a2 = 2;
const A3 = 3;
a4 = 4;

function f(){
    var f1 = 1;
    let f2 = 2;
    const F3 = 3;
    f4 = 4;
}

f();

function g(){
    console.log(a1); // выведет
    console.log(a2); // выведет
    console.log(A3); // выведет
    console.log(a4); // выведет
    console.log(f1); // не выведет
    console.log(f2); // не выведет
    console.log(F3); // не выведет
    console.log(f4); // выведет
}

g();

function h(){
    var a1 = 0; // сработает
    let a2 = 0; // сработает "но"
    const A3 = 0; // сработает "но"
    a4 = 0; // сработает
    f4 = 0; // сработает
}

h();

var a1 = 0; // сработает
let a2 = 0; // не сработает
const A3 = 0; // не сработает
a4 = 0; // сработает
```

**А теперь разберем что происходит:**

1. Переменные `a1`, `a2`, `A3`, `a4` объявлены на уровне программы, а `f1`, `f2`, `F3`, `f4` на уровне функции.

2. Что будет с `var`: 
    
    1. Из-за контекстной типизации `a1` станет глобальной, а `f1` локальной переменными, из-за чего в функции `g` `а1` будет видна, а `f1` нет

    2. В функции `h` или в самой программе переменную `a1` можно будет объявить заново

3. Что будет с `let`:

    1.  Из-за блочной типизации `a2` будет видна всей программе, а `f2` только функции в которой объявлена, из-за чего в функции `g` `а2` будет видна, а `f2` нет

    2. В функции `h` переменную `a2` можно будет объявить заново, "но" теперь `a2` для всего блока программы будет новой и старая не будет доступна

    3. На уровне блока, на котором была задана `a2`, переобъявить её уже будет нельзя

4. Что будет с `const`:

    1.  Из-за блочной типизации `A3` будет видна всей программе, а `F3` только функции в которой объявлена, из-за чего в функции `g` `A3` будет видна, а `F3` нет

    2. В функции `h` переменную `A3` можно будет объявить заново, "но" теперь `A3` для всего блока программы будет новой и старая не будет доступна

    3. На уровне блока, на котором была задана `A3`, переобъявить её уже будет нельзя

    4. Изменить значение никакой из переменных этого типа будет невозможно

5. Что будет с `без ключевого слова`:

    1. Обе переменные станут глобальными из-за глобальной области видимости

    2. Переобъявление не отличаеться от переназначения так что технически её можно будет изменять как угодно в каком угодно блоке программы.

#### Почему `var` считается устаревшей?

Как мы увидели выше: переменные объявленые через `var` могут переобъявляться из-за чего могут возникать массы ошибок и несостыковок в коде. Что б решить эту проблему был создан `let` который в свою очередь такими проблемами не страдает.

### Типы данных

В JS есть 7 примитивных типо данных.

**Тип данных** — типы того, какого типа значение может хранить переменная.

**Примитивы (примитивные типы данных)** — типы данных которые не являються объектами и не имеют методов.

***Простыми словами:*** самые простые системные типы данных.

**Примитивы в JS:**

* `Boolean` – логический тип данных, хранит 2 вида значений: `true` или `false`

* `Number` – числовой тип данных, хранит числа в диапазоне приблизительно от _-2*10^307_ до _2*10^307_, в случаее передачи значения меньше будет записіваться `-Infinity`, а больше – `Infinity`

* `String` – строчный тип данных, хранит строку текста почти неограниченого размера

* `null` – ключевое слово, которое означает что нулевое или "пустое" значение

* `undefined` – ключевое слово, которое означает что переменная не хранит никакого значение, по умолчанию присваивается всем переменных при объявлении без значение, за исключением `const`

### Типизация

Типизация JS – это динамическая, слабая, неявная.

**А теперь попробуем понять:**

* Динамическая – значит что переменная не привязана к единому типу при объявлении, переменная может хранить разные типы по ходу использования программы

* Слабая – значит что при проделование действий с переменной одного типа действий другого типа не будет вызывать ошибку. *Известный пример*: `1 + "2" == "12"`, то есть что число попытались просумировать со строкой, но это не вызвало оишбку и сработало

* Неявная – значит что при объявлении не нужно "явно" указывать тип переменной. *Например как это в С++ с явной типизацией:* `string a = "a"`, когда в JS хватит `let a = "a"`, без указание типа

***Статья, где эта тема раскрыта глубже:*** https://tproger.ru/explain/tipizacija-jazykov-programmirovanija-razbiraemsja-v-osnovah/


#### Что же нам дают эти зания?

Из типизации JS мы можем извлечь те факты, что:

* Нам не нужно следить за типами на уровне программы

* Нам не нужно объявлять переменную указывая её тип 

* Мы можем для одной переменной присваивать значения разных типов

### Расмотрим конкретно разные типы

#### Boolean

Это логический тип данных, который используется в местах, где нужно в переменной хранить 2 варианта значения: ДА (`true`) или НЕТ (`false`)

***Объявления переменных этого типа могут выглядить так:***

```js
let t = true;
let f = false;
```

Используються они, в основном, в условных конструкциях, которые мы расмотрим позже

#### Number

Числовой тип данных. Может хранить разные числа: положительные, отрицательные, ноль, целые, не целые...

***Объявления переменных этого типа могут выглядить так:***

```js
let n = 2;
let p = 3.14;
let m = -4;
let o = 0;
```

Так же для преобразование переменных другого типа в `Number` можно использовать функции `ParseInt(string)`, `ParseFloat(string)` или просто созданием объекта `Number()`

#### String

Сточный тип данных, хранит в себе текст.

***Объявления переменных этого типа могут выглядить так:***

```js
let txt1 = "Hello";
let txt2 = 'World';
let txt3 = `!`;
```

Разницы между кавычками нету (за исключением ``, но про это не сейчас), главное что б они открывали и закрывали строку одновременно.

Так же для преобразование переменных другого типа в `String` можно использовать функции `String()` или `.toString()`

Так же для строк существует очень большое количество методов, перечень которых и инструкции к ним можно най по ссылке: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String

## Условные конструкции

Переменные это конечно хорошо, но надо ж как-то с ними работать и вот условные конструкции это один из способов прописывания логики программы.

### if...else

Самая известная и часто используемая конструкция.

В `if` передаёться условие, если условие истинное то выполняеться то, что в блоке `if` в ином случае то, что в блоке `else`

***Синтаксис выглядит примерно так:***

```js 
if(/*условние: или логическое выражение или переменная типа Boolean*/){
    // действие если условие == true
}
else{
    // действие если условие == false
}
```

Так же в эту конструкцию можно добавить `else if`

***Пример применения:***

```js 
if(/*условние 1: или логическое выражение или переменная типа Boolean*/){
    // действие если условие 1 == true
}
else if(/*условние 2: или логическое выражение или переменная типа Boolean*/){
    // действие если условие 1 == false, но условие 2 == true
}
...
else{
    // действие если условие 1 == false и действие 2 == false
}
```

Таких конструкций `else if` можно добавлять любое количество раз

### Логические операторы

`==` – равенство

`!=` – неравенство

`&&` – логическое `И`, то есть оба условия в конструкции `(условие 1)&&(условие 2)` доожны быть `true`

`||` – логическое `ИЛИ`, то есть хотя б одно условие в конструкции `(условие 1)||(условие 2)` доожно быть `true`


### switch..case...default

Так же условная конструкция которая укорачивает код который возможно написать через `if...else if...else`

`switch...case...default` отличается тем, что мы в switch передаём какою либо переменную, а потом конструкция сравнивает эту переменную с каждым значением `case` и если никакого совпадения с `case` не нашлось выполняеться блок `default`

***Синтаксис выглядит примерно так:***

```js
switch(/*переменная которую сравниваем*/){
    case /*значение 1*/:
        // действие если совпало значение 1
        break;
    case /*значение 2*/:
        // действие если совпало значение 2
        break;
    ...
    default:
        // действие если никакое значение не совпало
        break;
}
```

`break` являеться обязательной командой в конце блоков, что б сравнение переменных не пошло дальше


### try...case...finally

Условный блок, при котором условием выполнения будет наличие или отсутвие ошибки в блоке кода `try`

***Синтаксис выглядит примерно так:***

```js
try{
    // блок кода который будет воспроизводить на поиск ошибки
}
catch(/*объект ошибки типа Error*/){
    // действие если ошибка
}
finally{
    // действие после выполнения блока, которое не будет воспроизводить на поиск ошибки
}
```

***Подробнее про объекты Error:*** https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error

## Циклы

### while

Цикл при котором действие выполняеться пока условие истинно

***Синтаксис выглядит примерно так:***

```js
while(/*условие: или логическое выражение или переменная типа Boolean*/){
    // действие если условие true
}
```

### do...while

Можно сказать разновидность цикла `while`, только в `while` сначала проверяется условие а потом действие, а в `do...while` наоборот — сначала действие, а потом проверка  

***Синтаксис выглядит примерно так:***

```js
do{
    // действие если условие true
} while(/*условие: или логическое выражение или переменная типа Boolean*/)
```

### for

Вид цикла с действием которое выполняеться до начала обхода, условием выполнения и действием которое выполняеться в конце каждого прохода

***Синтаксис выглядит примерно так:***

```js
for(/*действие в начале*/; /*условие выполнения*/; /*действие в конце каждого прохода*/){
    // действие пока условие true
}
```

### Ключевые слова `break` и `continue`

`break` используеться для досрочного выхода из цикла, то есть завершение работы цикла вне зависимости от условия

***Пример использования:***

```js
for(let i = 0; i < 10; i ++){
    if(i % 3 == 0){ // если число делится на 3 без остатка
        break;
    }
    consoe.log(i);
}
```

То есть цикл выполнялся пока не наткнулся на первое число которое делится на 3

`continue` используеться для досрочного прекращения прохода цикла и перехода на следующий проход, то есть используется когда вам надо что б все после его вызова не выполнялось в это проходе, а выполнялось сразу сделующий проход

```js
for(let i = 0; i < 10; i ++){
    if(i % 3 == 0){ // если число делится на 3 без остатка
        continue;
    }
    consoe.log(i);
}
```

То есть для чисел которые деляться на 3 не выполнялся `console.log()`, а сразу выполнялся следующий прогон цикла

## Практические задания на данных знаниях

Для лучшего закрепления предлогаю выполнить несколько простых задач, которые проверят, насколько вы поняли этот уровень материала, все знания которые могут быть нужны для выполнения задач есть выше.

**Все решения задач будут в папке "Задачи" и будут пронумерованы**, но не рекомендую вам ими пользваться пока у вас самих не получится

1. Допишите в начало кода такие объявления переменных, что б остальной код заработал как написано в коментарии. Не все места для написания кода обязаны быть заполнены
    ```js 
    // запишите ваши объявления сюда
    function func1(){
        // или сюда
    }

    function func2(){
        try{
            A1 = 0;
        }
        catch(e){
            console.log("Нельзя изменять переменную A1");
        }
        console.log(a2);
    }

    func1();
    func2();
    ```

    *(Должны произойти все выводы в консоль)*

2. Напишите цикл который выведет в консоль все числа от 1 до 100 включительно которые деляться на 5 или на 7 (`n % /*число*/ == 0` – условие делимости `n` на какое либо число)

3. Напишите блок кода который будет в случае выполнения действия `throw ""` выводилась фраза "Произошла ошибка" и после этого выводилась фраза "Ошибки обработаны"